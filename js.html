<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
	<ul class="list" id="ulist" style="background-color: black;width: 100px;">
		<li class="item" style="background-color: red;">1<li id='item1' style="background-color: red;">11</li></li>
		<li class="item" style="background-color: red;">2</li>
		<li class="item" style="background-color: red;">3</li>
		<li class="item2" style="background-color: red;">4</li>
		<li class="item" style="background-color: red;">5</li>
		<li class="item" style="background-color: red;">6</li>
	</ul>
</body>
<script type="text/javascript">
	//防抖
	// var fn=function(){
 // 		console.log('a');
 // 	}
	// var ul=document.getElementById('ulist');
	// ul.onclick=debounce(fn,2000);
	// function debounce(fn, interval) {
 //    	let timeout = null;
 //    	console.log('setnull')
 //    	return function () {
 //    		console.log(timeout)
 //        	clearTimeout(timeout)//清除前一次触发的时间
 //       		timeout = setTimeout(() => {
 //            	fn();
 //        	}, interval)
 //    	}
	// }


	//打印杨辉三角
	// function Combination(m,n){
	// 		if(n == 0) return 1;
	// 		else if(m == n) return 1; 
	// 		else return Combination(m-1,n-1)+Combination(m-1,n);
	// 	}
	// 	function Pascal(n){ 
	// 		for( var i = 0 ; i < n ; i++ ){ 
	// 			let arr=[];
	// 			for ( var j = 0 ; j <= i ; j++ ) {
	// 				arr.push(Combination(i,j));
	// 			}
	// 			console.log(arr.join(' '));
	// 		}
 //        }
 //     Pascal(6);


//eventLoop
	// var pro=new Promise((res,rej)=>{
	// 	console.log('promise_1');
	// 	res();
	// }).then(()=>{
	// 	console.log('promise_2');
	// })
	// Promise.resolve()
	//     .then(() => {  
	//         console.log('promise 1')
	//     })
	//     .then(() => {
	//         console.log('promise 2')
	//     })
	// console.log('start')

	// const interval = setInterval(() => {  
	//   console.log('setInterval')
	// }, 0)

	// setTimeout(() => {  
	//   console.log('setTimeout 1')
	//   Promise.resolve()
	//       .then(() => {
	//         console.log('promise 3')
	//       })
	//       .then(() => {
	//         console.log('promise 4')
	//       })
	//       .then(() => {
	//         setTimeout(() => {
	//           console.log('setTimeout 2')
	//           Promise.resolve()
	//               .then(() => {
	//                 console.log('promise 5')
	//               })
	//               .then(() => {
	//                 console.log('promise 6')
	//               })
	//               .then(() => {
	//                 clearInterval(interval)
	//               })
	//         }, 0)
	//       })
	// }, 0)

	// var ul=document.getElementById('ulist');
	// ul.addEventListener('click',(e)=>{
	// 	console.log('event',e);
	// 	var target=e.target||e.srcElement
	// 	if(target&&target.className==='item'){
	// 		alert('a');
	// 	}
	// })
	// //字符串的正则方法
	// var re=new RegExp('a+','ig');
	// console.log(re.flags);
	// var str='ahhhjjaanaaauaakka';
	// console.log(str.match(re));//返回匹配到的字符串数组，不是全局匹配情况下则返回index
	// console.log(str.replace(re,'o'));//替换
	// console.log(str.search(re));//搜索第一个匹配到的选项的索引
	// console.log(str.split(re));//将字符串按照正则规则匹配



	// //原型链

	// let f=function() {
	// 	this.a=1;
	// 	this.b=2;
	// };
	// //在自身拥有a和b属性的函数里创建一个对象o
	// let o=new f();
	// //在f的原型里定义属性
	// f.prototype.b=3;
	// f.prototype.c=4;
	// //不要在f函数的原型上直接定义 f.prototype = {b:3,c:4};这样会直接打破原型链
	// console.log('o',o,o.prototype);
	// console.log(o.constructor.prototype,o.__proto__);//o的构造函数的原型(o.__proto__)有属性b和c
	// console.log(o.__proto__.__proto__);//是Object.prototype
	// console.log(o.__proto__.__proto__.__proto__);//这就是原型链的末尾，即 null
	// console.log(o.a);//1
	// console.log(o.b);//2,原型链上有b,但不会被访问，我们称之为“属性遮蔽 (property shadowing)”
	// console.log(o.c);//c不是o自身属性，往原型上找，该属性值为4
	// // 综上，整个原型链如下: 
	// // {a:1, b:2} ---> {b:3, c:4} ---> Object.prototye---> null
	// let o1 = {
	//   a: 2,
	//   m: function(){
	//     return this.a + 1;
	//   }
	// };
	// let p=Object.create(o1);//建立一个继承自o1的对象
	// console.log('o1',o1,o1.__proto__);
	// p.a=4
	// console.log(p.m())//这里的this指向当前继承的对象而不是继承的函数所在原型的对象，则a为p中的4

	// console.log(Array.prototype);
	// console.log(Function.prototype);
</script>
</html>
